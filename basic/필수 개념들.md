### html vs html5

### GET vs POST
GET
1. GET 주소에 ? 로 주소로 데이터를 전송한다.
2. 멱등하다.
POST
3. 데이터는 body에 담아서 보냄.
4. 데이터가 노출되지 않아 안전하다.

### TCP VS USP
둘다 데이터를 전송할 떄 사용하는 프로토콜이다.

TCP : 
1. 연결형으로 신뢰성을 보장한다.
2. 3-WAY HANDSHAKING 과정을 통해서 전송 순서를 보장하나 속도가 UDP에 비해 낮다.

UDP:
1. 비연결형으로 연속성이 중요하지 않다.
2. 3-WAY HANDSHAKING 과정이 없기 때문에 빠르다. 

### HTTP VS HTTPS
HTTP: 암호화가 되지 않기 때문에 패킷을 들여다 볼 수 있다.
HTTPS: 암호화가 되어 있기 때문에 패킷을 들여다 볼 수 없다.
- 암호화 방식
  -  대칭키 암호화
    -  키 노출 위험성이 큰 대신 빠름 
  -  비대칭키 암호화
    -  키 노출 위험성이 적은 대신 느림

### RESTFUL API
REST의 규칙을 지켜서 만든 API를 뜻함.
성능의 향상 보다는 규칙을 통한 API이해도와 호환성을 높이기 위함.


### 동기 / 비동기

동기 
-> 1:1 고객 대응 방식, BLOCKING 방식

비동기 
-> 1:N 고객 대응 방식, NON-BLOCKING 방식

### 프록시 서버
PROXY: 대리라는 뜻을 갖고 있음.
클라이언트가 프록시 자신을 거쳐 다른 네트워크에 접속할 수 있또록 중간에서 대리역할을 하는 서버 

사용 이유:
-> 캐시 데이터 활용을 위함, IP 노출을 하지 않게 하기 위함.

1. FORWARD
2. REVERSE

### DNS
-> IP 주소와 도메인 이름을 변환하는 서버 

### 패킷
-> 패키지와 버킷의 합성어로 데이터의 전송 단위를 뜻함.

### 쿠키와 세션의 차이
-> 쿠키는 브라우저에 저장되는 K-V 형태의 데이터파일, 로컬에 저장 
-> 세션이란 브라우저가 종료되기 전까지 유저의 요청을 유지하게 해주는 기술

### 프로세스와 스레드
프로세스
-> 운영체제로부터 자원을 할당받은 작업의 단위
-> 운영체제로부터 CODE, DATA, STACK, HEAP 을 할당 받음 
스레드
-> 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위
-> STACK만 따로 할당받고 나머지 영역은 공유하다. 

### 컨텍스트 스위칭
-> 하나의 프로세스가 실행되고 있는 상태에서 다른 프로세스를 실행할 수 있도록 컨텍스트를 교환하는 작업을 컨텍스트 스위칭이라고 한다.

1. 프로세스 컨텍스트 스위칭
  -> 공유 되는 영역이 적기 때문에 시간이 더 걸린다.
2. 스레드 컨텍스트 스위칭
  -> 공유 되는 영역이 많이 때문에 시간이 상대적으로 덜 걸린다.

### STACK 과 HEAP
코드 : 실행할 프로그램의 코드 
데이터 영역 : 전역변수, 정적 변수
힙 : 사용자의 동적 할당 (글로벌)
스택 : 지역 변수 매개변수 (로컬)

### JWT
-> 웹 유저의 인증을 위해 사용되는 암호화된 토큰
HEADER, PAYLOAD,SIGNATURE 3가지 정보를 담겨져있다.

1. JWT 발급 과정
2. 

### OAUTH
-> 유저들 입장에서는 다양한 서비스에 본인의 IP/PW를 노출시키는 것이 부담스러움
TOKEN
ACCESS TOKEN
REFRESH TOKEN 

### 대칭키와 비대칭키 암호화 차이점
대칭키
-> 암호화/ 복호화 하는 키가 동일함.
비대칭키
-> 암호화/ 복호화 하는 키가 다르다.

### SQL INJECTION

### CSRF/XSS
XSS
-> 웹사이트에 스크립트가 주입되는 방식 
CSRF
-> 권한이 있는 사용자를 이용해 서버에 요청을 보내는 방식

### 트랙잭션의 ACID
-> 트랙잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 가르키는 약어
1. 원자성
  -> 실행이 되었다면 중단이 되지 않는 것을 보장 
2. 일관성
   -> 데이터의 상태는 일관된 상태여야 한다.
3. 고립성
   -> 트랙잭션을 수행하는 도중에 다른 연산작업이 끼어들지 못하도록 하는것 
4. 지속성
   -> 성공적으로 트랙잭션이 수행되었다면 그 결과는 영원히 반영되어야 함을 의미

### 데드락
-> 프로세스가 자원을 얻지못해 다음 처리를 하지 못하는 경우

4가지 조건이 성립할 때 발생한다.
1. 상호 배제
2. 점유 대기
3. 비선점
4. 순환 대기

데드락 예방 조건
위의 조건 4가지 중 하나를 무력화 시킨다.

### Base64 인코딩:   

Base64 인코딩은 이진 데이터를 텍스트 데이터로 변환하는 방법 중 하나입니다. 이진 데이터는 0과 1로 이루어져 있어 텍스트 데이터로 안전하게 전송하거나 저장하기 위해 사용됩니다. Base64는 64개의 다른 문자로 이루어진 알파벳을 사용하며, 원본 이진 데이터를 6비트씩 나누어 이를 64개의 다른 문자로 매핑하여 인코딩합니다.

### 사용자 패스워드 전송/보관 방법:

패스워드를 안전하게 전송하기 위해 HTTPS를 사용합니다.
패스워드를 안전하게 저장하기 위해 해시 함수 (예: bcrypt, Argon2)를 사용하여 저장하고, 솔트(salt)와 함께 사용하여 공격을 어렵게 만듭니다.

### 시스템 콜(System Call):
시스템 콜은 운영 체제 커널에 서비스를 요청하는 프로그램의 인터페이스입니다. 프로그램이 운영 체제의 기능을 활용하기 위해 시스템 콜을 사용하며, 이를 통해 파일 I/O, 네트워크 통신, 메모리 관리 등의 작업을 수행할 수 있습니다.

### .so와 .a 파일의 차이:

.so 파일 (Shared Object): 공유 라이브러리로, 여러 프로그램에서 동적으로 로드하여 사용할 수 있습니다.
.a 파일 (Archive): 정적 라이브러리로, 컴파일 시에 프로그램에 포함되며 실행 파일이 더 크지만 독립적으로 실행 가능합니다.

### MySQL과 MongoDB의 차이점:

MySQL: 관계형 데이터베이스 시스템, 스키마 기반, SQL 쿼리 사용, 트랜잭션 지원.
MongoDB: NoSQL 데이터베이스, 문서 지향, JSON 형식 데이터 저장, 유연한 스키마, NoSQL 쿼리 사용.

### HTTP/2의 특징:

다중 스트림: 여러 요청 및 응답을 병렬로 처리하여 성능 향상.
헤더 압축: 헤더 정보를 압축하여 대역폭 절약.
서버 푸시: 서버에서 클라이언트로 데이터를 미리 보낼 수 있어 성능 개선.
이진 프레임 사용: 효율적인 데이터 전송을 위해 이진 프레임 사용.

### Firewall 동작 원리:

Firewall은 네트워크 트래픽을 감시하고 제어하는 보안 장치로, 정책에 따라 패킷을 허용 또는 거부합니다.
패킷 필터링, 상태ful 인스팩션, 프록시 방화벽 등 다양한 방식으로 동작할 수 있으며, 보안 정책을 준수하여 악성 트래픽을 차단합니다.

### Docker와 Virtual Machine (VM)의 차이점:

Docker: 운영 체제 수준의 가상화, 가볍고 빠르며 컨테이너 단위로 애플리케이션 패키징 및 실행.
VM: 하드웨어 수준의 가상화, 무겁고 느리며 게스트 운영 체제가 필요하고 가상 머신 단위로 애플리케이션 실행.

### AMD와 Intel CPU의 차이점:

아키텍처, 성능, 전력 효율 등 다양한 요인에 따라 다를 수 있으며, 세부적인 차이는 시기에 따라 변할 수 있습니다.

### CRDT (Conflict-free Replicated Data Type):

분산 환경에서 복제된 데이터의 일관성을 보장하는 데이터 구조.
동시 수정 및 병합 가능하며, 충돌을 최소화하고 해결할 수 있도록 설계됨.

### CORS (Cross-Origin Resource Sharing):

웹 페이지에서 다른 도메인의 리소스에 접근하기 위한 보안 정책.
웹 브라우저에서 동일 출처 정책으로 인해 다른 도메인에서 데이터를 요청하려면 CORS 헤더를 설정해야 함.

### CI/CD (Continuous Integration/Continuous Deployment):

소프트웨어 개발 프로세스에서 지속적인 통합과 지속적인 배포를 의미하며, 자동화된 빌드, 테스트 및 배포를 통해 개발 및 릴리스 프로세스를 가속화합니다.

### 동시 사용자 1만명을 지원하는 채팅 서버 구축:

고성능 웹소켓 서버 사용.
로드 밸런서를 통해 트래픽 분산.
클러스터링 및 수평 확장 구현.
데이터베이스 샤딩 또는 NoSQL 데이터베이스 사용.

### 보안 관련 사고의 원인과 대책:

원인: 약점을 이용한 해킹, 미감사된 코드, 사회 공학, 약한 인증 및 권한 관리 등.
대책: 보안 강화, 정기적인 감사 및 펜테스트, 교육 및 인식 확대, 정책 및 접근 제어 개선.

### 대용량 로그 시스템 구축:

분산 로그 수집 시스템 (예: ELK 스택, Fluentd) 사용.
데이터를 분산 스토리지 또는 분산 데이터베이스에 저장.
로그 롤링, 압축 및 보관 정책 구현.
모니터링 및 경고 설정.

### APM:
Application Performance Monitoring 의 약자로 프로세스의 성능을 모니터링하는 툴
제니퍼 소프트와 제니퍼, scouter가 2탑이다.

### 클로저:
클로저(closure)는 함수가 변수를 포함하고 있는 경우, 그 함수가 변수를 참조할 때 변수가 스코프 밖에서 선언되었더라도 해당 변수의 값을 계속 사용할 수 있게 하는 기능을 말합니다. 이를 통해 변수의 스코프가 확장되고, 해당 변수는 함수가 종료된 후에도 사용될 수 있습니다.

변수의 스코프가 스택(stack)에서 힙(heap)으로 이동한다는 것은 다음과 같은 상황을 설명합니다:

일반적인 상황: 함수 내에서 변수를 선언하면 해당 변수는 함수의 스코프 내에서만 사용 가능하며, 함수가 실행 중일 때만 메모리 스택에 저장됩니다. 함수 실행이 끝나면 해당 변수는 스택에서 제거됩니다.

클로저 사용: 함수 내에서 변수를 선언하고, 그 함수를 리턴하거나 다른 함수에 전달하면 변수가 클로저에 포함됩니다. 이때 해당 변수는 함수 스코프 밖에서도 사용 가능하며, 이 변수는 메모리 스택이 아닌 메모리 힙에 저장됩니다. 따라서 함수가 종료되어도 해당 변수가 유지됩니다.

장점: 
1. 함수의 캡슐화
2. 불필요한 전역변수 선언 

### 함수의 inline:
인라인화는 코드를 최적화하거나 성능을 향상시키는 데 사용될 수 있지만, 코드의 가독성과 유지보수성을 희생할 수 있으므로 주의가 필요합니다. Go 언어에서는 컴파일러가 최적화를 수행하며, 함수 호출을 인라인화할지 여부를 결정합니다. 
